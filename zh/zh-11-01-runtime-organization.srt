0
00:00:03,730 --> 00:00:10,730
In this video we're going to begin our discussion of run time systems. Now, at
在这段视频中，我们将开始讨论运行时系统。现在，在

1
00:00:12,670 --> 00:00:17,410
this point we have actually covered the entire front end of the compiler which
这一点我们实际上已经涵盖了编译器的整个前端，

2
00:00:17,410 --> 00:00:22,679
consists of the three phases, lexical analysis, parsing and semantic analysis
包括词法分析、句法分析和语义分析三个阶段

3
00:00:22,679 --> 00:00:28,730
And these three passes or these three phases together, their job is to really
而这三关或者这三个阶段加在一起，他们的工作就是真正

4
00:00:28,730 --> 00:00:35,730
enforce the language semantics or the language definition. So, we know. After
强制执行语言语义或语言定义。所以，我们知道。之后

5
00:00:38,629 --> 00:00:43,550
these three phases are done that if no errors have been generated by anyone of
这三个阶段在以下情况下进行：如果以下任何人都没有生成错误

6
00:00:43,550 --> 00:00:47,590
those phases then the program is actually a valid program in the programming
这些阶段则程序实际上是编程中的有效程序

7
00:00:47,590 --> 00:00:51,829
language that we're compiling And at this point the compiler is going to be able to
我们正在编译的语言，在这一点上，编译器将能够

8
00:00:51,829 --> 00:00:56,910
produce codes to produce a translation of the program that you can actually execute.
生成代码以生成您可以实际执行的程序的翻译。

9
00:00:56,910 --> 00:01:00,440
And I should say that of course. Enforcing the language definition is just one
当然，我应该这么说。强制执行语言定义只是其中之一

10
00:01:00,440 --> 00:01:05,210
purpose of the front-end. The front-end also builds the data structures that are
前端的用途。前端还构建以下数据结构

11
00:01:05,209 --> 00:01:10,720
needed to do co-generation as we seen but there is a real. Once we get through the
就像我们看到的那样，需要做热电联产，但有一个真正的。一旦我们通过了

12
00:01:10,720 --> 00:01:15,720
front-end we no longer looking for errors in the program. We're no longer trying to
前端我们不再寻找程序中的错误。我们不再试图

13
00:01:15,720 --> 00:01:19,660
figure out whether it's a valid program. Now we're really down to the point where
找出它是否是一个有效的程序。现在我们真的到了这样一个地步

14
00:01:19,660 --> 00:01:25,970
we're going to generate code And that is a job at the back end. So cogeneration is
我们要生成代码，这是后端的工作。所以热电联产是

15
00:01:25,970 --> 00:01:30,570
certainly part of it. The other big part of the back end is program optimization so
当然是其中的一部分。后端的另一个重要部分是程序优化，因此

16
00:01:30,570 --> 00:01:35,790
doing transformations to improve the program. But before we can talk about
进行转换以改进程序。但在我们谈到

17
00:01:35,790 --> 00:01:42,230
either one of those things, we need to talk about Runtime organization And why is
这两件事中的任何一件，我们都需要讨论运行时组织，为什么

18
00:01:42,230 --> 00:01:46,630
that, well because we need to understand what it is we're trying to generate before
这是因为我们需要了解我们之前想要产生的是什么

19
00:01:46,630 --> 00:01:50,320
we can talk about how we generated and have that makes sense. So first, we're
我们可以谈谈我们是如何产生和拥有的，这是有意义的。所以首先，我们要

20
00:01:50,320 --> 00:01:54,870
gonna talk about what the, the translator program looks like and how it's organized
我要谈谈翻译程序是什么样子的，以及它是如何组织的

21
00:01:54,870 --> 00:01:57,950
and then we'll talk about algorithms and code generation algorithms were actually
然后我们将讨论算法和代码生成算法

22
00:01:57,950 --> 00:02:02,710
producing those things. And this is a well-understood area or at least some very
生产那些东西。这是一个广为人知的地区，或者至少是一些非常

23
00:02:02,710 --> 00:02:06,080
standard techniques that are widely used and those are the ones we wanted to cover
广泛使用的标准技术，这些都是我们想要介绍的技术

24
00:02:06,080 --> 00:02:13,080
and, and encourage you to use in your project. The main thing we're going to
并鼓励您在您的项目中使用。我们要做的主要事情是

25
00:02:14,629 --> 00:02:19,489
cover in this sequence of videos is the management of Runtime resources and in
本系列视频的内容包括运行时资源的管理和

26
00:02:19,489 --> 00:02:24,310
particular I'm going to be stressing the correspondence and the distinction between
我将特别强调两者之间的对应和区别

27
00:02:24,310 --> 00:02:29,879
static and dynamic structures. So static structures are things that exist to
静电和动态结构。所以静电结构是存在于

28
00:02:29,879 --> 00:02:35,099
compile time and dynamic structures, those are the things that exist or happen at
编译时和动态结构，这些都是存在或发生在

29
00:02:35,099 --> 00:02:42,099
Runtime And, this is probably the most important distinction for you to try to
运行时，这可能是您要尝试的最重要的区别

30
00:02:42,120 --> 00:02:45,930
understand if you really want to understand how a compiler works. What
如果您真的想了解编译器是如何工作的，请理解。什么

31
00:02:45,930 --> 00:02:49,569
happens to the compile time and what happens at run time. Having a clear
发生在编译时和运行时发生的事情。有一个清晰的

32
00:02:49,569 --> 00:02:55,140
separation in your mind between what is done by the compiler and what is deferred
在您的脑海中区分编译器所做的工作和被延迟的工作

33
00:02:55,140 --> 00:02:59,709
to when the target program or the generated program actually runs that is
设置为目标程序或生成的程序实际运行的时间，即

34
00:02:59,709 --> 00:03:05,819
key to really understanding how compilers work. And we'll also be talking about
真正理解编译器如何工作的关键。我们还将讨论

35
00:03:05,819 --> 00:03:10,670
storage organization. So how memory is used to store the data structures of the
存储组织。那么如何使用内存来存储

36
00:03:10,670 --> 00:03:17,670
executing program. So let's begin at the beginning. So initially there is the
正在执行程序。那么让我们从头开始吧。所以最初有一个

37
00:03:19,310 --> 00:03:22,230
operating system and the operating system is the only thing that is running on the
操作系统，而操作系统是唯一运行在

38
00:03:22,230 --> 00:03:27,670
machine and when a program is invoke. When the user says he wants to run a program,
机器以及当程序被调用时。当用户说他想要运行程序时，

39
00:03:27,670 --> 00:03:32,370
what happens while the operating system is going to allocate space for the program
当操作系统要为程序分配空间时会发生什么

40
00:03:32,370 --> 00:03:37,819
the code for the program is going to be loaded into that space and then the
该程序的代码将被加载到该空间中，然后

41
00:03:37,819 --> 00:03:42,499
operating system is going to execute a job to the entry point or the main function of
操作系统将执行作业到入口点或主函数

42
00:03:42,499 --> 00:03:49,349
the program and then your program will be off and running. So, let's take a look at
该程序，然后您的程序将关闭并运行。那么我们来看一下，

43
00:03:49,349 --> 00:03:54,200
what the organization memory looks like very roughly when the Operating System
当操作系统运行时，组织内存大致是什么样子

44
00:03:54,200 --> 00:03:59,480
began execution of the compiled program. So we're gonna draw our pictures of memory
开始执行编译后的程序。所以我们要画一幅记忆的图画

45
00:03:59,480 --> 00:04:04,859
like this. That would be just a big block and there will be a starting address at
像这样。那将只是一个很大的挡路，并且将有一个开始地址在

46
00:04:04,859 --> 00:04:08,969
the, a lower address and a higher address and this is all the memory that is
一个较低的地址和一个较高的地址，这就是

47
00:04:08,969 --> 00:04:14,799
allocated to your program. Now into some portion of that space goes to code for the
分配给您的程序。现在进入该空间的某一部分，转到

48
00:04:14,799 --> 00:04:20,060
program so the actual compiled code for the program is loaded usually at one end
程序，因此程序的实际编译代码通常在一端加载

49
00:04:20,060 --> 00:04:25,320
of the memory space allocated to the program. And then there is a bunch. Of
分配给程序的内存空间的大小。然后还有一堆。的

50
00:04:25,320 --> 00:04:29,850
other space that is going to be used for other things and we'll talk about that in
其他空间将用于其他用途，我们将在

51
00:04:29,850 --> 00:04:36,470
a minute. Before going on, I want to say a few words about this pictures of Run-time
稍等片刻。在继续之前，我想就这张运行时图片说几句话

52
00:04:36,470 --> 00:04:40,840
Organization because I'm going to be drawing a lot of them over the next few
因为在接下来的几年里我会画很多这样的照片

53
00:04:40,840 --> 00:04:47,210
videos. So, it's just traditional to have memory drawn as a rectangle with the low
视频。因此，传统的做法是将内存绘制为带有低位的矩形

54
00:04:47,210 --> 00:04:52,340
address at the top and the high address at the bottom. There's nothing magic about
地址在顶部，高位地址在底部。没有什么神奇之处

55
00:04:52,340 --> 00:04:55,620
that, just a convention we could adjust it easily every verse or order of the
这只是一种惯例，我们可以很容易地调整它的每一节或每一个顺序

56
00:04:55,620 --> 00:05:01,370
address, no big deal. And then we'll be drawing lines to the limit different
地址，没什么大不了的。然后我们会把线画到不同的极限

57
00:05:01,370 --> 00:05:07,530
regions of this memory showing different kinds of data and how they're stored in
显示不同类型数据以及它们在中的存储方式的内存区域

58
00:05:07,530 --> 00:05:12,370
the memory allocated to the program. And clearly these pictures are simplifications
分配给程序的内存。很明显，这些图片是简单化的

59
00:05:12,370 --> 00:05:17,450
if this, is a virtual memory system for example, there's no guarantee that these
例如，如果这是一个虚拟内存系统，就不能保证这些

60
00:05:17,450 --> 00:05:23,370
data is actually laid out contiguously but it helps to understand you know, what the
数据实际上是连续布局的，但它有助于理解

61
00:05:23,370 --> 00:05:29,500
different kinds of data are. And what the, a compiler needs to do with them to have
不同种类的数据是相同的。编译器需要对它们做什么才能拥有

62
00:05:29,500 --> 00:05:36,500
simple pictures like this. So coming back to our picture of run time organization,
像这样简单的图片。所以回到我们对运行时组织的描述上来，

63
00:05:37,580 --> 00:05:43,350
we have some block memory and the first portion of that is occupied by the actual
我们有一些挡路内存，其中的第一部分被实际的

64
00:05:43,350 --> 00:05:46,970
generated code for the program and then there was this other space and we're what
为程序生成代码，然后有另一个空间，我们是什么

65
00:05:46,970 --> 00:05:51,930
goes to that space? Well, what goes to that space is the data for the program. So
去那个地方吗？进入那个空间的是程序的数据。所以

66
00:05:51,930 --> 00:05:57,520
all the data is in the rest of the space and the tricky thing about code generation
所有的数据都在睡觉的空间里，代码生成的棘手之处在于

67
00:05:57,520 --> 00:06:01,870
that the compiler is responsible for generating the code but it's also
编译器负责生成代码，但它也

68
00:06:01,870 --> 00:06:06,620
responsible for orchestrating the data. So the compiler has to decide what the lay of
负责编排数据。所以编译器必须决定哪一层

69
00:06:06,620 --> 00:06:11,530
the data is going to be and then generate code that correctly manipulates that data
数据将被转换，然后生成正确操作该数据的代码

70
00:06:11,530 --> 00:06:16,810
so there are references of course in the code. To the data and the code and data
所以代码中当然有引用。数据、代码和数据

71
00:06:16,810 --> 00:06:20,500
need to be designed, the code and the layout of the data, excuse me, need to be
需要设计的，代码和数据的布局，打扰一下，需要

72
00:06:20,500 --> 00:06:26,580
designed together so that the generated program will function correctly. Now, it
一起设计，以便生成的程序能够正常运行。现在，它

73
00:06:26,580 --> 00:06:31,870
turns out that this actually more than one kind of data that the compiler is going to
事实证明，这实际上不只是编译器要处理的一种数据

74
00:06:31,870 --> 00:06:36,520
be interested in and what we'll be talking about. In the next video is the different
对我们将要谈论的内容感兴趣。下一个视频中的不同之处在于

75
00:06:36,520 --> 00:06:39,440
kinds of data and the different distinction between the kinds of data that
数据类型和数据类型之间的不同区别

76
00:06:39,440 --> 00:06:41,490
go in this data area.
进入这个数据区。

