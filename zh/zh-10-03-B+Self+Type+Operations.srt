0
00:00:00,530 --> 00:00:03,679
So now, let's move on to the least upper bound operation. And once again, T and
现在，让我们来看看最小上界运算。再一次，T和

1
00:00:03,679 --> 00:00:08,500
T prime will be any types except self-type. The least upper bound of self-type
T素数将是除自类型之外的任何类型。自体型的最小上界

2
00:00:08,500 --> 00:00:12,530
with itself is just self-type, and I think that that's pret ty clear. The
它本身就是一种自我类型，我认为这一点非常清楚。这个

3
00:00:12,530 --> 00:00:17,550
least upper bound of self-types of C and T will be the least upper bound of the class
C和T的自身类型的最小上界将是类的最小上界

4
00:00:17,550 --> 00:00:22,300
C and T. And once again, this is because C is the largest type, that self-type could
再说一次，这是因为C是最大的类型，自我类型可以

5
00:00:22,300 --> 00:00:28,180
be. And therefore, the largest type is guaranteed to cover both self-types of C.
就是这样。因此，最大的类型保证覆盖C的两个自身类型。

6
00:00:28,180 --> 00:00:35,180
And T is going to be the least upper bound of C and T. And least of our bounds is the
T将是C和T的最小上界，我们的最小上界是

7
00:00:35,339 --> 00:00:41,449
symmetric operations, so if I reverse these two arguments, the answer is the same.
对称运算，所以如果我颠倒这两个论点，答案是相同的。

8
00:00:41,449 --> 00:00:44,649
And finally if self-type is not one of the arguments at least upper bound then
最后，如果Self-type不是参数之一，那么至少上界是这样的

9
00:00:44,649 --> 00:00:48,809
we just do what we do before. The self-type, the least upper bound definition
我们只是做我们以前做过的事。自我类型，最小上界定义

10
00:00:48,809 --> 00:00:53,719
excuse me, has not changed for class names for type names other than self-type.
对不起，对于除Self-type之外的其他类型名称的类名，没有更改。

